(* autogenerated from lockservice *)
From Perennial.goose_lang Require Import prelude.
From Perennial.goose_lang Require Import ffi.disk_prelude.


Module LockServer.
  Definition S := struct.decl [
    "mu" :: lockRefT;
    "locks" :: mapT boolT;
    "lastSeq" :: mapT uint64T;
    "lastReply" :: mapT boolT
  ].
End LockServer.


(* the lockservice Clerk lives in the client
   and maintains a little state. *)
Module Clerk.
  Definition S := struct.decl [
    "primary" :: struct.ptrT LockServer.S;
    "cid" :: uint64T;
    "seq" :: uint64T
  ].
End Clerk.

(* common.go *)

(* Lock(lockname) returns OK=true if the lock is not held.
   If it is held, it returns OK=false immediately. *)
Module LockArgs.
  Definition S := struct.decl [
    "Lockname" :: uint64T;
    "CID" :: uint64T;
    "Seq" :: uint64T
  ].
End LockArgs.

Module LockReply.
  Definition S := struct.decl [
    "OK" :: boolT
  ].
End LockReply.

(* Unlock(lockname) returns OK=true if the lock was held.
   It returns OK=false if the lock was not held. *)
Module UnlockArgs.
  Definition S := struct.decl [
    "Lockname" :: uint64T;
    "CID" :: uint64T;
    "Seq" :: uint64T
  ].
End UnlockArgs.

Module UnlockReply.
  Definition S := struct.decl [
    "OK" :: boolT
  ].
End UnlockReply.


(* nondet.go *)

Axiom nondet: val.

(* server.go *)

(* server Lock RPC handler.
   returns true iff error *)
Definition LockServer__TryLock: val :=
  rec: "LockServer__TryLock" "ls" "args" "reply" :=
    lock.acquire (struct.loadF LockServer.S "mu" "ls");;
    let: ("last", "ok") := MapGet (struct.loadF LockServer.S "lastSeq" "ls") (struct.loadF LockArgs.S "CID" "args") in
    (if: "ok" && (struct.loadF LockArgs.S "Seq" "args" ≤ "last")
    then
      struct.storeF LockReply.S "OK" "reply" (Fst (MapGet (struct.loadF LockServer.S "lastReply" "ls") (struct.loadF LockArgs.S "CID" "args")));;
      lock.release (struct.loadF LockServer.S "mu" "ls");;
      #false
    else
      MapInsert (struct.loadF LockServer.S "lastSeq" "ls") (struct.loadF LockArgs.S "CID" "args") (struct.loadF LockArgs.S "Seq" "args");;
      let: ("locked", <>) := MapGet (struct.loadF LockServer.S "locks" "ls") (struct.loadF LockArgs.S "Lockname" "args") in
      (if: "locked"
      then struct.storeF LockReply.S "OK" "reply" #false
      else
        struct.storeF LockReply.S "OK" "reply" #true;;
        MapInsert (struct.loadF LockServer.S "locks" "ls") (struct.loadF LockArgs.S "Lockname" "args") #true);;
      MapInsert (struct.loadF LockServer.S "lastReply" "ls") (struct.loadF LockArgs.S "CID" "args") (struct.loadF LockReply.S "OK" "reply");;
      lock.release (struct.loadF LockServer.S "mu" "ls");;
      #false).

(* server Unlock RPC handler.
   returns true iff error *)
Definition LockServer__Unlock: val :=
  rec: "LockServer__Unlock" "ls" "args" "reply" :=
    lock.acquire (struct.loadF LockServer.S "mu" "ls");;
    let: ("last", "ok") := MapGet (struct.loadF LockServer.S "lastSeq" "ls") (struct.loadF UnlockArgs.S "CID" "args") in
    (if: "ok" && (struct.loadF UnlockArgs.S "Seq" "args" ≤ "last")
    then
      struct.storeF UnlockReply.S "OK" "reply" (Fst (MapGet (struct.loadF LockServer.S "lastReply" "ls") (struct.loadF UnlockArgs.S "CID" "args")));;
      lock.release (struct.loadF LockServer.S "mu" "ls");;
      #false
    else
      MapInsert (struct.loadF LockServer.S "lastSeq" "ls") (struct.loadF UnlockArgs.S "CID" "args") (struct.loadF UnlockArgs.S "Seq" "args");;
      let: ("locked", <>) := MapGet (struct.loadF LockServer.S "locks" "ls") (struct.loadF UnlockArgs.S "Lockname" "args") in
      (if: "locked"
      then
        MapInsert (struct.loadF LockServer.S "locks" "ls") (struct.loadF UnlockArgs.S "Lockname" "args") #false;;
        struct.storeF UnlockReply.S "OK" "reply" #true
      else struct.storeF UnlockReply.S "OK" "reply" #false);;
      MapInsert (struct.loadF LockServer.S "lastReply" "ls") (struct.loadF UnlockArgs.S "CID" "args") (struct.loadF UnlockReply.S "OK" "reply");;
      lock.release (struct.loadF LockServer.S "mu" "ls");;
      #false).

Definition MakeServer: val :=
  rec: "MakeServer" <> :=
    let: "ls" := struct.alloc LockServer.S (zero_val (struct.t LockServer.S)) in
    struct.storeF LockServer.S "locks" "ls" (NewMap boolT);;
    struct.storeF LockServer.S "lastSeq" "ls" (NewMap uint64T);;
    struct.storeF LockServer.S "lastReply" "ls" (NewMap boolT);;
    struct.storeF LockServer.S "mu" "ls" (lock.new #());;
    "ls".

(* rpc.go *)

(* Returns true iff error *)
Definition CallTryLock: val :=
  rec: "CallTryLock" "srv" "args" "reply" :=
    Fork (let: "dummy_reply" := ref (zero_val (struct.t LockReply.S)) in
          Skip;;
          (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
            LockServer__TryLock "srv" "args" "dummy_reply";;
            Continue));;
    (if: nondet #()
    then LockServer__TryLock "srv" "args" "reply"
    else #true).

(* Returns true iff error *)
Definition CallUnlock: val :=
  rec: "CallUnlock" "srv" "args" "reply" :=
    Fork (let: "dummy_reply" := ref (zero_val (struct.t UnlockReply.S)) in
          Skip;;
          (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
            LockServer__Unlock "srv" "args" "dummy_reply";;
            Continue));;
    (if: nondet #()
    then LockServer__Unlock "srv" "args" "reply"
    else #true).

(* client.go *)

Definition MakeClerk: val :=
  rec: "MakeClerk" "primary" "cid" :=
    let: "ck" := struct.alloc Clerk.S (zero_val (struct.t Clerk.S)) in
    struct.storeF Clerk.S "primary" "ck" "primary";;
    struct.storeF Clerk.S "cid" "ck" "cid";;
    struct.storeF Clerk.S "seq" "ck" #1;;
    "ck".

(* waits until the lock service grants us the lock *)
Definition Clerk__Lock: val :=
  rec: "Clerk__Lock" "ck" "lockname" :=
    let: "args" := struct.new LockArgs.S [
      "Lockname" ::= "lockname";
      "CID" ::= struct.loadF Clerk.S "cid" "ck";
      "Seq" ::= struct.loadF Clerk.S "seq" "ck"
    ] in
    struct.storeF Clerk.S "seq" "ck" (struct.loadF Clerk.S "seq" "ck" + #1);;
    let: "reply" := ref (zero_val (struct.t LockReply.S)) in
    let: "errb" := ref_to boolT #false in
    Skip;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      "errb" <-[boolT] CallTryLock (struct.loadF Clerk.S "primary" "ck") "args" "reply";;
      (if: (![boolT] "errb" = #false)
      then
        (if: struct.get LockReply.S "OK" (![struct.t LockReply.S] "reply")
        then Break
        else
          struct.storeF LockArgs.S "Seq" "args" (struct.loadF Clerk.S "seq" "ck");;
          struct.storeF Clerk.S "seq" "ck" (struct.loadF Clerk.S "seq" "ck" + #1))
      else #());;
      Continue);;
    struct.get LockReply.S "OK" (![struct.t LockReply.S] "reply").

Definition Clerk__Unlock: val :=
  rec: "Clerk__Unlock" "ck" "lockname" :=
    let: "args" := struct.new UnlockArgs.S [
      "Lockname" ::= "lockname";
      "CID" ::= struct.loadF Clerk.S "cid" "ck";
      "Seq" ::= struct.loadF Clerk.S "seq" "ck"
    ] in
    struct.storeF Clerk.S "seq" "ck" (struct.loadF Clerk.S "seq" "ck" + #1);;
    let: "reply" := ref (zero_val (struct.t UnlockReply.S)) in
    let: "errb" := ref (zero_val boolT) in
    Skip;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      "errb" <-[boolT] CallUnlock (struct.loadF Clerk.S "primary" "ck") "args" "reply";;
      (if: (![boolT] "errb" = #false)
      then Break
      else #());;
      Continue);;
    struct.get UnlockReply.S "OK" (![struct.t UnlockReply.S] "reply").

